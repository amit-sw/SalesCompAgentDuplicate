# src/contest_agent.py

# Importing required libraries for message handling and data validation
from langchain_core.messages import SystemMessage, HumanMessage
from pydantic import BaseModel
from src.create_llm_message import create_llm_message
from src.book_appointment import handle_appointment_request, book_appointment
from datetime import datetime
from typing import Optional

# Data model for structuring the LLM's response
class ContestDecision(BaseModel):
    nextsteps: str # Stores the next steps or actions for the user
    decision: str  # Stores the decision type ('Info', 'URLform', 'Other')
    timeslot: Optional[datetime] = None
    email: Optional[str]
    name: Optional[str]

# When ContestAgent object is created, it's initialized with a model. 
# The main entry point is the contest_agent method. You can see workflow.add_node for contest_agent node in graph.py

class ContestAgent:
    
    def __init__(self, model):
        """
        Initialize the ContestAgent with a ChatOpenAI model.
        
        :param model: An instance of the ChatOpenAI model used for generating responses.
        """
        self.model = model

    def get_contest_info(self) -> str:
        """
        Retrieve contest rules from a text file. Make sure contestrules.txt exists in the root directory.
        
        :return: A string containing the contest rules.
        """
        with open('contestrules.txt', 'r') as file:
            contest_rules = file.read()
        return contest_rules

    def book_appt(self):
        # Calls external function to fetch available appointment slots
        # This likely connects to a calendar or scheduling system
        available_slots = handle_appointment_request()
        # Debug print to see the available slots in the console
        print(available_slots)
        # Returns the list of available time slots
        return available_slots

    def get_available_slots(self, available_slots):
        # Creates a prompt template for the AI to format the available slots
        time_slot_prompt = f"""
         You are an appointment booking scheduler. Present the following slots in a brief, easy-to-read format. Keep 
         the message compact but always maintain a friendly, professional, and helpful tone throughout the interaction.

        Available slots: {available_slots}

        Instructions:
        1. Tell the user that they need to book a consultation with Sales Comp team and you will help them book an appointment 
        2.  List the slots in a clean and easy to read format
        3. Keep your message under 100 words
        4. Simply ask "Please choose a time slot."
        """

        # Sends the prompt to the AI model to get a formatted response
        response = self.model.invoke(time_slot_prompt)
        # Returns just the content of the AI's response (the formatted slot list)
        return response.content

    def confirm_appointment(self, selected_slot, user_email):
        # Debug print to indicate appointment confirmation process
        print(f"Confirming the appointment {selected_slot} for {user_email}")
        
        result = book_appointment(selected_slot, user_email)
        
        print(f"Confirmed appointment {result=}")

        # Returns a confirmation message with next steps
        # Note: This seems incomplete as it doesn't include actual next steps
        response = """Your appointment is confirmed. The next steps are, after our consultation meeting we will 
        put together a proposal and send it to the President of Sales and the CFO for approval. We will keep you
        posted once we have the decision. """
        return result


    def get_contest_url(self) -> str:
        """
        Read and return the contest form URL from a text file. Make sure contesturl.txt exists in the root directory

        :return: A string containing contest URL.
        """
        with open('contesturl.txt', 'r') as file:
            contest_url = file.read()
        return contest_url

    def generate_contest_response(self) -> str:
        """
        Generate a response for contest-related queries using the ChatOpenAI model.
        
        :param user_query: The original query from the user.
        :return: A string response generated by the language model.
        """
        contest_prompt = f"""
        You are a Sales Commissions expert. Users will ask you about starting a SPIF or sales contest. Maintain a 
        friendly, professional, and helpful tone.

        STEP 1: VALIDATE USER INFO
        1. Ask the user to provide their full name and email address to proceed. Update 'decision' to [askforuserinfo] and 'nextsteps' to politely ask the user for name and email address 
        2. If you HAVE all the information (Full name and Email address), categorize user's query per categories in Step 2.
        3. If you DON'T HAVE all the information (Full name and Email address), politely, ask the user for this information.

        STEP 2: EXPLAIN THE FOLLOWING PROCESS IN PLAIN ENGLISH
        1. Submit initial request 3+ weeks before start of the quarter
        2. Book an appointment with Sales Compensation team
        3. Complete Intake Form (sent via email)
        4. Review proposal with Sales Compensation team
        5. Await President of Sales and CFO approval
        6. Launch documentation preparation with Communications team


        STEP 3: UPDATE 'decision' to [BookAppointment]. 

        STEP 4: If user has provided a preferred slot, UPDATE 'decision to [ConfirmAppointment]

        STEP 5: Send an email with a link for Contest URL
        
        """
        # Create a well-formatted message for LLM by passing the contest_prompt above to create_llm_messages
        llm_messages = create_llm_message(contest_prompt)

        # Invoke the model with the well-formatted prompt, including SystemMessage, HumanMessage, and AIMessage
        llm_response = self.model.with_structured_output(ContestDecision).invoke(llm_messages)
        
        full_response = llm_response
        
        return full_response


    def contest_agent(self, state: dict) -> dict:
        """
        Process user's contest-related questions and return appropriate responses.
        
        :param state: Dictionary containing conversation state and user's message
        :return: Dictionary containing:
            - lnode: Name of the current node ("contest_agent")
            - responseToUser: Contest info, URL, or next steps based on the decision
            - category: Type of response ("contest")
        """
        # Generate a response based on the user's initial message
        # Get AI's decision and recommended next steps
        llm_response = self.generate_contest_response()
        
        # Determine the appropriate response based on the LLM's decision
        # Handle BookAppointment case
        if llm_response.decision == 'BookAppointment':
            print(f"At step 1, {llm_response.name}, {llm_response.email}")
            available_slots = self.book_appt()
            user_response = self.get_available_slots(available_slots)
            print(f"At step 2, {llm_response.name}, {llm_response.email}")

            return {
                "lnode": "contest_agent", 
                "responseToUser": user_response,
                "category": "contest",
                "name": llm_response.name,
                "email": llm_response.email
            }

        elif llm_response.decision == 'ConfirmAppointment':
            user_response = self.confirm_appointment(llm_response.timeslot, llm_response.email)

        else:  # Handle 'Other' case by sending AI's recommended next steps
            user_response = llm_response.nextsteps

        # Return the updated state with the generated response and the category set to 'contest'
        return {
            "lnode": "contest_agent", 
            "responseToUser": user_response,
            "category": "contest"
        }
